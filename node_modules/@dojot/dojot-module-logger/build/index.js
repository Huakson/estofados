"use strict";
/*Dojot Logger Library*/
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const body_parser_1 = __importDefault(require("body-parser"));
const express = __importStar(require("express"));
const winston = __importStar(require("winston"));
/* Levels of debug */
const debugLevels = ["debug", "info", "warn", "error"];
function formatParams(info) {
    const { timestamp, level, message } = info, args = __rest(info, ["timestamp", "level", "message"]);
    const ts = timestamp.slice(0, 19).replace("T", " ");
    const filename = Object.keys(args).length ? ` -- |${args.filename}` : "";
    return `<${ts}>${filename} -- ${level}: ${message}`;
}
/**
 * @description This log module allows the developer to create usefull logs
 * messages with a certain level of severity. This module will work with four
 * levels of logging, wich are dividide into:
 *
 * ERROR: This level serves as the general error feature. It should be used
 * whenever the software encounters an unexpected error that prevents further
 * processing (e.g. cant connect to a port, an error connecting with kafka, a
 * connection refused).
 *
 * WARN: Events that are likely to lead to an error in the future, however, can
 * be corrected by the system runtime (e.g. a fail connection with database,
 * fail trying to retrieve a data, fail trying to get a callback)
 *
 * INFO: System update information events (e.g A new socket connection, a new
 * kafka producer).
 *
 * DEBUG: Events for debug readings, usefull when developers are trying to
 * understand the code (e.g. Kafka Producer is not yet ready,
 * Retrieving/creating new topic). The level severity of logs can be changed
 * via runtime by a http request into: ".../setLog?level={level of your
 * debug}".
 *
 * This modules provides a route via express routes for runtime log level
 * change. An example to create a customized logger:
 *
 * logger.debug("Will initialize ingestion handler device-data at topic \
 * f968b47f-6db7-4434-9e9c-175feb42c68b", {filename: "your module name"})
 *
 * the response will be:
 *
 * <19:48:14 02/08/2018> -- |your module name| -- DEBUG: Will initialize ingestion
 * handler device-data at topic f968b47f-6db7-4434-9e9c-175feb42c68b.
 */
const internalLogger = winston.createLogger({
    exitOnError: false,
    format: winston.format.combine(winston.format((info) => {
        info.level = info.level.toUpperCase();
        return info;
    })(), winston.format.timestamp({ format: "HH:mm:ss DD/MM/YYYY" }), winston.format.colorize({ all: true }), winston.format.printf(formatParams)),
    transports: [
        new winston.transports.Console({
            handleExceptions: true,
            level: "debug",
        }),
    ],
});
const logger = {
    debug: (data, config) => { internalLogger.debug(data, config); },
    error: (data, config) => { internalLogger.error(data, config); },
    getLevel: () => internalLogger.transports[0].level,
    info: (data, config) => { internalLogger.info(data, config); },
    setLevel: (level) => {
        if (debugLevels.indexOf(level) >= 0) {
            internalLogger.transports[0].level = level;
            return 0;
        }
        else {
            return -1;
        }
    },
    warn: (data, config) => { internalLogger.warn(data, config); },
};
exports.logger = logger;
/**
 * Adds two endpoints related to logging configuration.
 * @param app The express application
 */
function getHTTPRouter() {
    const router = express.Router();
    router.use(body_parser_1.default.json());
    router.put("/log", (req, res) => {
        if (req.body.level !== undefined && req.body.level !== null) {
            if (logger.setLevel(req.body.level) === 0) {
                // Set log level
                res.set(200).send("Level of debugger is set to " + req.body.level);
            }
            else {
                res.status(400).send("unknown level: " + req.body.level + ", valid are " + debugLevels);
            }
        }
        else {
            res.status(400).send("undefined level of debugger");
        }
    });
    // tslint:disable-next-line:variable-name
    router.get("/log", (_req, res) => {
        res.set(200).header({
            "Content-Type": "application/json",
        }).send(JSON.stringify({
            level: logger.getLevel(),
        }));
    });
    return router;
}
exports.getHTTPRouter = getHTTPRouter;
//# sourceMappingURL=index.js.map